// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `get_node_holder`, `get_node`, `get_runtime`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `NodeEventDto`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`

/// Initialize logging
void initLogging() => RustLib.instance.api.crateApiInitLogging();

/// Start the Cyberfly node
Future<NodeInfo> startNode({
  required String dataDir,
  String? walletSecretKey,
  required List<String> bootstrapPeers,
  String? region,
}) => RustLib.instance.api.crateApiStartNode(
  dataDir: dataDir,
  walletSecretKey: walletSecretKey,
  bootstrapPeers: bootstrapPeers,
  region: region,
);

/// Stop the node
Future<void> stopNode() => RustLib.instance.api.crateApiStopNode();

/// Check if node is running
bool isNodeRunning() => RustLib.instance.api.crateApiIsNodeRunning();

/// Get node status - synchronous version using shared state
NodeStatusDto getNodeStatus() => RustLib.instance.api.crateApiGetNodeStatus();

/// Get node info
NodeInfo? getNodeInfo() => RustLib.instance.api.crateApiGetNodeInfo();

/// Get discovered peers - synchronous version using shared state
List<PeerInfoDto> getPeers() => RustLib.instance.api.crateApiGetPeers();

/// Send gossip message
Future<void> sendGossip({required String topic, required String message}) =>
    RustLib.instance.api.crateApiSendGossip(topic: topic, message: message);

/// Send latency request to measure peer latency
Future<void> sendLatencyRequest({required String peerId}) =>
    RustLib.instance.api.crateApiSendLatencyRequest(peerId: peerId);

/// Store data in local database with signature for sync
Future<void> storeData({
  required String dbName,
  required String key,
  required List<int> value,
  required String publicKey,
  required String signature,
}) => RustLib.instance.api.crateApiStoreData(
  dbName: dbName,
  key: key,
  value: value,
  publicKey: publicKey,
  signature: signature,
);

/// Store data without signature (local only, not synced)
Future<void> storeDataLocal({
  required String dbName,
  required String key,
  required List<int> value,
}) => RustLib.instance.api.crateApiStoreDataLocal(
  dbName: dbName,
  key: key,
  value: value,
);

/// Get data from local database
Future<Uint8List?> getData({required String dbName, required String key}) =>
    RustLib.instance.api.crateApiGetData(dbName: dbName, key: key);

/// Request sync from peers
Future<void> requestSync({PlatformInt64? sinceTimestamp}) =>
    RustLib.instance.api.crateApiRequestSync(sinceTimestamp: sinceTimestamp);

/// Sign a message using Ed25519
String signMessageWithKey({
  required String secretKeyHex,
  required String message,
}) => RustLib.instance.api.crateApiSignMessageWithKey(
  secretKeyHex: secretKeyHex,
  message: message,
);

/// Verify an Ed25519 signature
bool verifyMessageSignature({
  required String publicKeyHex,
  required String message,
  required String signatureHex,
}) => RustLib.instance.api.crateApiVerifyMessageSignature(
  publicKeyHex: publicKeyHex,
  message: message,
  signatureHex: signatureHex,
);

/// Generate a new Ed25519 keypair
KeyPairDto generateKeypair() => RustLib.instance.api.crateApiGenerateKeypair();

/// Generate database name from name and public key
/// Format: <name>-<public_key_hex> (matching cyberfly-rust-node)
String generateDbName({required String name, required String publicKeyHex}) =>
    RustLib.instance.api.crateApiGenerateDbName(
      name: name,
      publicKeyHex: publicKeyHex,
    );

/// Verify that the database name matches the public key
bool verifyDbName({required String dbName, required String publicKeyHex}) =>
    RustLib.instance.api.crateApiVerifyDbName(
      dbName: dbName,
      publicKeyHex: publicKeyHex,
    );

/// Extract name part from database name (removes public key suffix)
String? extractNameFromDb({required String dbName}) =>
    RustLib.instance.api.crateApiExtractNameFromDb(dbName: dbName);

/// Validate timestamp (check if within acceptable range)
bool validateTimestamp({required PlatformInt64 timestamp}) =>
    RustLib.instance.api.crateApiValidateTimestamp(timestamp: timestamp);

/// Greet function for testing
String greet({required String name}) =>
    RustLib.instance.api.crateApiGreet(name: name);

/// Keypair for signing
@freezed
sealed class KeyPairDto with _$KeyPairDto {
  const factory KeyPairDto({
    required String publicKey,
    required String secretKey,
  }) = _KeyPairDto;
}

/// Node info returned to Flutter
@freezed
sealed class NodeInfo with _$NodeInfo {
  const factory NodeInfo({
    required String nodeId,
    required String publicKey,
    required bool isRunning,
  }) = _NodeInfo;
}

/// Node status for Flutter
@freezed
sealed class NodeStatusDto with _$NodeStatusDto {
  const factory NodeStatusDto({
    required bool isRunning,
    String? nodeId,
    required int connectedPeers,
    required int discoveredPeers,
    required BigInt uptimeSeconds,
    required BigInt gossipMessagesReceived,
    required BigInt storageSizeBytes,
    required BigInt totalKeys,
    required int syncOperations,
    required BigInt latencyRequestsSent,
    required BigInt latencyResponsesReceived,
  }) = _NodeStatusDto;
}

/// Peer info for Flutter
@freezed
sealed class PeerInfoDto with _$PeerInfoDto {
  const factory PeerInfoDto({
    required String nodeId,
    required String publicKey,
    String? address,
    String? region,
    String? version,
    BigInt? latencyMs,
    required bool isMobile,
  }) = _PeerInfoDto;
}
